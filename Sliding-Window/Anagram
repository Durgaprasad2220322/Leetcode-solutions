Given two strings s and p, return an array of all the start indices of p's anagrams in s.
You may return the answer in any order. explain the question(Leetcode 438)

class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> result = new ArrayList<>();
        if (p.length() > s.length()) return result;

        int[] freqP = new int[26];
        int[] window = new int[26];

        // Build frequency of p
        for (char c : p.toCharArray()) {
            freqP[c - 'a']++;
        }

        int left = 0, right = 0;
        int k = p.length();

        while (right < s.length()) {
            // Add current character to window
            window[s.charAt(right) - 'a']++;

            // If window size exceeds p length → shrink from left
            if (right - left + 1 > k) {
                window[s.charAt(left) - 'a']--;
                left++;
            }

            // If window size == k → compare
            if (right - left + 1 == k) {
                if (isSame(window, freqP)) {
                    result.add(left);
                }
            }

            right++;
        }

        return result;
    }

    // Helper function to compare frequency arrays
    private boolean isSame(int[] a, int[] b) {
        for (int i = 0; i < 26; i++) {
            if (a[i] != b[i]) return false;
        }
        return true;
    }
}


Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise. 
In other words, return true if one of s1's permutations is the substring of s2.(Leetcode 567)

class Solution {
    public boolean checkInclusion(String s1, String s2) {
        if (s1.length() > s2.length()) return false;

        int[] freq1 = new int[26];
        int[] window = new int[26];

        // Count characters of s1
        for (char c : s1.toCharArray()) {
            freq1[c - 'a']++;
        }

        int left = 0;
        int k = s1.length();

        for (int right = 0; right < s2.length(); right++) {

            // add current character
            window[s2.charAt(right) - 'a']++;

            // ensure window size stays equal to s1 length
            if (right - left + 1 > k) {
                window[s2.charAt(left) - 'a']--;
                left++;
            }

            // if window size exactly equals s1 size → compare
            if (right - left + 1 == k) {
                if (matches(freq1, window)) return true;
            }
        }

        return false;
    }

    // helper function to compare frequencies
    private boolean matches(int[] a, int[] b) {
        for (int i = 0; i < 26; i++) {
            if (a[i] != b[i]) return false;
        }
        return true;
    }
}
